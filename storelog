#!/usr/local/bin/bash
# FIXME: Replace me with #!/bin/bash
# Thanks, Mac
#!/bin/bash

#
# storelog - Store nginx access logs to a database.
#

# Write to stderr.
_stderr () {
  # ISO8601 timestamp, precision in seconds.
  local _now
  _now=$(date -Iseconds)
  >&2 echo "{\"time_iso8601\": \"${_now}\" \"msg\": \"$*\"}"
}

# cat reads on stdin, by default, and outputs to stdout. We use that behavior to
# make this script accept piped and redirected output.
_stdin=$(cat)
readarray -t LOG_LINES < <(echo "${_stdin}")

FIRST_LINE="${LOG_LINES[0]}"
# If we only have a single line and its length is 0, we likely received no input.
if [[ "${#LOG_LINES[@]}" -eq "1" ]] && [[ "${#FIRST_LINE}" -eq "0" ]]; then
  _stderr "No input received"
  exit 0
fi

PROCESSED_REQUESTS=0
FAILED_PROCESSING=0

declare -a INSERT_LEGIT # Legitimate requests
declare -a INSERT_JUNK  # Everything else (e.g. scans)
INSERT_LEGIT+=("BEGIN TRANSACTION;\n")
INSERT_JUNK+=("BEGIN TRANSACTION;\n")
for LINE in "${LOG_LINES[@]}"; do
  local request_uri
  if request_uri=$(jq -e '.request_uri' <<< "${LINE}" > /dev/null 2>&1); then
    _stmt="INSERT INTO logs (entry) VALUES ('${LINE}');\n"
    # FIXME: Add all entries to one table; delineate legit vs everything else
    if [[ "${request_uri}" =~ ^/hit/ ]]; then
      INSERT_LEGIT+=("${_stmt}")
    else
      INSERT_JUNK+=("${_stmt}")
    fi
    PROCESSED_REQUESTS=$(( PROCESSED_REQUESTS + 1 ))
  else
    # Invalid input short-circuits immediately.
    FAILED_PROCESSING=$(( FAILED_PROCESSING + 1 ))
  fi
done

if [ "${#INSERT_LEGIT[@]}" -gt "1" ]; then
  INSERT_LEGIT+=("COMMIT;\n")
  # Write to the database.
  echo -e "${INSERT_LEGIT[*]}" | sqlite3 logs.db
else
  _stderr "No valid logs to store"
fi

_stderr "Processed: ${PROCESSED_REQUESTS}  Failed: ${FAILED_PROCESSING}"
